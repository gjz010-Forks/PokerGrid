<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/icon.png" />
    <title>‰πùÂÆ´Áâå</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                    }
                }
            }
        }
    </script>
    <style>
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        .card-fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .card-fade-out {
            animation: fadeOut 0.3s ease-in-out;
        }
        
        .card {
            aspect-ratio: 2/3;
            perspective: 1000px;
        }
        
        .card-inner {
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }
        
        .card-front, .card-back {
            backface-visibility: hidden;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
        }
        
        .card-back {
            transform: rotateY(180deg);
            background-image: repeating-linear-gradient(45deg, rgba(93, 92, 222, 0.1) 0, rgba(93, 92, 222, 0.1) 10px, transparent 10px, transparent 20px);
        }
        
        .dark .card-back {
            background-image: repeating-linear-gradient(45deg, rgba(93, 92, 222, 0.2) 0, rgba(93, 92, 222, 0.2) 10px, transparent 10px, transparent 20px);
        }
        
        /* Ëä±Ëâ≤È¢úËâ≤ÂÆö‰πâ */
        .heart {
            color: #E53E3E; /* Á∫¢Ëâ≤ */
        }
        
        .dark .heart {
            color: #FC8181; /* Ê∑±Ëâ≤Ê®°Âºè‰∏ãÁöÑÁ∫¢Ëâ≤ */
        }
        
        .diamond {
            color: #ED8936; /* Ê©ôËâ≤ */
        }
        
        .dark .diamond {
            color: #F6AD55; /* Ê∑±Ëâ≤Ê®°Âºè‰∏ãÁöÑÊ©ôËâ≤ */
        }
        
        .spade {
            color: #805AD5; /* Á¥´Ëâ≤ */
        }
        
        .dark .spade {
            color: #9F7AEA; /* Ê∑±Ëâ≤Ê®°Âºè‰∏ãÁöÑÁ¥´Ëâ≤ */
        }
        
        .club {
            color: #2D3748; /* Ê∑±ÁÅ∞Ëâ≤/ÈªëËâ≤ */
        }
        
        .dark .club {
            color: #E2E8F0; /* Ê∑±Ëâ≤Ê®°Âºè‰∏ãÁöÑÁÅ∞ÁôΩËâ≤ */
        }
        
        /* Ensure all inputs have at least 16px font size on mobile */
        @media (max-width: 768px) {
            input, button, select, textarea {
                font-size: 16px !important;
            }
        }
        
        /* Disable text selection for the game interface */
        body {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* Re-enable text selection for input elements */
        input, textarea {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-3xl">
        <!-- Language Selector -->
        <div class="flex justify-end mb-4 items-center">
            <label for="language-selector" class="mr-2 text-gray-700 dark:text-gray-300 text-sm">Language:</label>
            <div class="relative w-48">
                <select id="language-selector" class="block appearance-none w-full bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 hover:border-gray-400 px-4 py-2 pr-8 rounded shadow leading-tight focus:outline-none focus:shadow-outline">
                    <!-- Language options will be populated here -->
                </select>
                <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700 dark:text-gray-300">
                    <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                </div>
            </div>
        </div>
        
        <div class="text-center mb-6">
            <h1 class="text-3xl font-bold mb-2" data-i18n="gameTitle"></h1>
            <p class="text-sm md:text-base text-gray-600 dark:text-gray-400 mb-1" data-i18n="gameDescription"></p>
            <p class="text-xs md:text-sm text-gray-500 dark:text-gray-500 mb-1" data-i18n="comboDescription"></p>
            <p class="text-sm text-gray-500 dark:text-gray-500">
                <span data-i18n="remainingCards"></span>: <span id="remaining-cards" class="font-semibold">52</span> | 
                <span data-i18n="score"></span>: <span id="score" class="font-semibold">0</span>
            </p>
        </div>
        
        <!-- Random Seed Display -->
        <div class="mb-4 flex justify-center">
            <div class="flex flex-col sm:flex-row items-center text-sm bg-gray-100 dark:bg-gray-800 rounded-lg p-2">
                <span class="mr-2 mb-1 sm:mb-0" data-i18n="randomSeed"></span>
                <code id="seed-display" class="bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded text-xs sm:text-sm break-all"></code>
                <button id="random-seed" class="ml-1 mt-1 sm:mt-0 text-primary hover:text-primary-dark px-1 py-1 rounded text-xs">üé≤</button>
                <button id="copy-seed" class="ml-2 mt-1 sm:mt-0 text-primary hover:text-primary-dark px-2 py-1 rounded text-xs">üìã <span data-i18n="copy"></span></button>
                <button id="share-game" class="ml-2 mt-1 sm:mt-0 text-primary hover:text-primary-dark px-2 py-1 rounded text-xs">‚ÜóÔ∏è <span data-i18n="share"></span></button>
                <button id="restart-game" class="ml-2 mt-1 sm:mt-0 bg-yellow-500 hover:bg-yellow-600 text-white px-2 py-1 rounded text-xs">üîÑ <span data-i18n="restart"></span></button>
                <button id="new-game-btn" class="ml-2 mt-1 sm:mt-0 bg-primary hover:bg-primary-600 text-white px-2 py-1 rounded text-xs">‚ûï <span data-i18n="newGame"></span></button>
            </div>
        </div>

        <!-- Seed Input for Starting Specific Game -->
        <div class="mb-4 flex justify-center">
            <div class="flex flex-col sm:flex-row items-center text-sm">
                <input type="text" id="seed-input" class="px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 w-full sm:w-auto mb-2 sm:mb-0" data-i18n-placeholder="enterSeed">
                <button id="start-from-seed" class="bg-primary hover:bg-primary-600 text-white px-4 py-2 rounded-lg ml-0 sm:ml-2" data-i18n="start"></button>
            </div>
        </div>

        <!-- Game Container with Card Counter -->
        <div class="flex flex-col md:flex-row mb-6 justify-center items-start gap-4">
            <!-- Game Playing Area (left) -->
            <div class="flex flex-col items-center">
                <!-- Current Card Display -->
                <div class="mb-6 flex justify-center">
                    <div class="text-center">
                        <p class="text-sm mb-2" data-i18n="currentCard"></p>
                        <div id="current-card" class="card w-16 h-24 md:w-20 md:h-30 mx-auto bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg shadow-md flex items-center justify-center text-lg md:text-xl font-bold">
                            <div class="card-inner">
                                <div class="card-front flex items-center justify-center">
                                    <span>?</span>
                                </div>
                                <div class="card-back"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Game Grid -->
                <div class="grid grid-cols-3 gap-2 md:gap-3 mb-6 max-w-xs mx-auto">
                    <!-- Grid cells will be dynamically generated here -->
                </div>
            </div>
            
            <!-- Card Counter (right) -->
            <div class="flex-shrink-0 w-full md:w-auto bg-white dark:bg-gray-800 rounded-lg p-3 shadow-md border border-gray-300 dark:border-gray-700">
                <h3 class="text-sm font-semibold mb-2 text-center text-gray-700 dark:text-gray-300" data-i18n="remainingDeck"></h3>
                <div id="card-counter" class="grid grid-cols-4 gap-1 text-center">
                    <!-- Card counter will be dynamically generated here -->
                </div>
            </div>
        </div>

        <!-- Game Messages -->
        <div id="message-area" class="text-center mb-4 h-12 flex items-center justify-center">
            <p id="game-message" class="text-sm md:text-base font-medium"></p>
        </div>
        
        <!-- Game Log -->
        <div class="mb-4 max-w-md mx-auto">
            <h3 class="text-sm font-semibold mb-2 text-gray-700 dark:text-gray-300" data-i18n="clearingRecord"></h3>
            <div id="game-log" class="bg-gray-100 dark:bg-gray-800 rounded-lg p-3 h-32 overflow-y-auto text-sm">
                <div class="space-y-1"></div>
            </div>
        </div>

        <!-- Game Result Modal (hidden by default) -->
        <div id="result-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
                <h2 class="text-2xl font-bold mb-4 text-center" data-i18n="gameOver"></h2>
                <p class="text-lg mb-2"><span data-i18n="finalScore"></span>: <span id="final-score" class="font-bold"></span></p>
                <p class="mb-4 text-sm text-gray-600 dark:text-gray-400" data-i18n="playAgainPrompt"></p>
                <div class="flex flex-wrap justify-center gap-2">
                    <button id="play-again" class="bg-primary hover:bg-primary-600 text-white px-4 py-2 rounded-lg" data-i18n="newGame"></button>
                    <button id="replay-same-seed" class="bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg" data-i18n="replaySameSeed"></button>
                    <button id="share-result" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg" data-i18n="shareResult"></button>
                </div>
            </div>
        </div>
        
        <!-- Toast Notification (for copy feedback) -->
        <div id="toast" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-lg opacity-0 transition-opacity duration-300 z-50">
            <!-- Toast content will be set dynamically -->
        </div>

        <script>
            // Multi-language support
            const LANGUAGES = {
                'zh-CN': {
                    name: '‰∏≠Êñá',
                    gameTitle: '‰πùÂÆ´Áâå',
                    gameDescription: 'ÂΩ¢ÊàêÂêåËä±(50ÂàÜ)„ÄÅÈ°∫Â≠ê(100ÂàÜ)„ÄÅ‰∏âÊù°(100ÂàÜ)ÊàñÂêåËä±È°∫(200ÂàÜ)Êù•Ê∂àÈô§Ë°å„ÄÅÂàóÊàñÂØπËßíÁ∫ø',
                    comboDescription: 'ÂêåÊó∂Ê∂àÈô§Ôºö2Ëøû√ó2ÂÄç„ÄÅ3Ëøû√ó4ÂÄç„ÄÅ4Ëøû√ó8ÂÄç',
                    remainingCards: 'Ââ©‰ΩôÁâåÊï∞',
                    score: 'ÂæóÂàÜ',
                    randomSeed: 'ÈöèÊú∫ÁßçÂ≠ê',
                    copy: 'Â§çÂà∂',
                    share: 'ÂàÜ‰∫´',
                    restart: 'ÈáçÂºÄ',
                    newGame: 'Êñ∞Ê∏∏Êàè',
                    enterSeed: 'ËæìÂÖ•ÁßçÂ≠êÂºÄÂßãÁâπÂÆöÊ∏∏Êàè',
                    start: 'ÂºÄÂßã',
                    currentCard: 'ÂΩìÂâçÁâå',
                    remainingDeck: 'ÁâåÁªÑÂâ©‰ΩôÊÉÖÂÜµ',
                    clearingRecord: 'Ê∂àÈô§ËÆ∞ÂΩï',
                    gameOver: 'Ê∏∏ÊàèÁªìÊùü!',
                    finalScore: 'ÊúÄÁªàÂæóÂàÜ',
                    playAgainPrompt: 'ÂÜçÊù•‰∏ÄÂ±ÄÔºåÊåëÊàòÊõ¥È´òÂàÜ!',
                    replaySameSeed: 'ÈáçÁé©Êú¨Â±Ä',
                    shareResult: 'ÂàÜ‰∫´ÊàêÁª©',
                    copied: 'Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø',
                    shareFailed: 'ÂàÜ‰∫´Â§±Ë¥•ÔºåËØ∑ÊâãÂä®Â§çÂà∂',
                    shareText: 'ÊàëÊ≠£Âú®https://poe.com/pokergridÁé©‰πùÂÆ´ÁâåÔºåËé∑Âæó‰∫Ü{score}ÂàÜÁöÑÂ•ΩÊàêÁª©ÔºåÈöèÊú∫ÁßçÂ≠êÊòØ{seed}Ôºå‰Ω†‰πüÊù•ÂíåÊàë‰∏ÄËµ∑Áé©ÂêßÔºÅ',
                    comboClearing: '{count}ËøûÊ∂àÈô§! ({multiplier}ÂÄçÂàÜÊï∞)',
                    patternPoints: '{pattern}! +{points}ÂàÜ',
                    cleared: 'Ê∂àÈô§',
                    singlePattern: 'Ê∂àÈô§ {pattern} [{cards}] = {points}ÂàÜ',
                    multiplePattern: '{count}ËøûÊ∂àÈô§! ({multiplier}) = {points}ÂàÜ',
                    gameOverMessage: 'Ê∏∏ÊàèÁªìÊùüÔºÅ',
                    // Card pattern names
                    'flush': 'ÂêåËä±',
                    'straight': 'È°∫Â≠ê',
                    'threeOfAKind': '‰∏âÊù°',
                    'straightFlush': 'ÂêåËä±È°∫'
                },
                'ja': {
                    name: 'Êó•Êú¨Ë™û',
                    gameTitle: '‰πùÂÆÆÁâå',
                    gameDescription: '„Éï„É©„ÉÉ„Ç∑„É•(50ÁÇπ)„ÄÅ„Çπ„Éà„É¨„Éº„Éà(100ÁÇπ)„ÄÅ„Çπ„É™„Éº„Ç´„Éº„Éâ(100ÁÇπ)„Åæ„Åü„ÅØ„Çπ„Éà„É¨„Éº„Éà„Éï„É©„ÉÉ„Ç∑„É•(200ÁÇπ)„ÇíÂΩ¢Êàê„Åó„Å¶Ë°å„ÄÅÂàó„Åæ„Åü„ÅØÂØæËßíÁ∑ö„ÇíÊ∂àÂéª',
                    comboDescription: 'ÂêåÊôÇÊ∂àÂéªÔºö2ÈÄ£√ó2ÂÄç„ÄÅ3ÈÄ£√ó4ÂÄç„ÄÅ4ÈÄ£√ó8ÂÄç',
                    remainingCards: 'ÊÆã„Çä„Ç´„Éº„Éâ',
                    score: '„Çπ„Ç≥„Ç¢',
                    randomSeed: '„É©„É≥„ÉÄ„É†„Ç∑„Éº„Éâ',
                    copy: '„Ç≥„Éî„Éº',
                    share: '„Ç∑„Çß„Ç¢',
                    restart: '„É™„Çπ„Çø„Éº„Éà',
                    newGame: 'Êñ∞Ë¶è„Ç≤„Éº„É†',
                    enterSeed: 'ÁâπÂÆö„ÅÆ„Ç≤„Éº„É†„ÇíÈñãÂßã„Åô„Çã„Åü„ÇÅ„ÅÆ„Ç∑„Éº„Éâ„ÇíÂÖ•Âäõ',
                    start: 'ÈñãÂßã',
                    currentCard: 'ÁèæÂú®„ÅÆ„Ç´„Éº„Éâ',
                    remainingDeck: '„Éá„ÉÉ„Ç≠„ÅÆÊÆã„Çä„Ç´„Éº„Éâ',
                    clearingRecord: 'Ê∂àÂéªË®òÈå≤',
                    gameOver: '„Ç≤„Éº„É†ÁµÇ‰∫Ü!',
                    finalScore: 'ÊúÄÁµÇ„Çπ„Ç≥„Ç¢',
                    playAgainPrompt: '„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§„Åó„Å¶È´òÂæóÁÇπ„Å´ÊåëÊà¶ÔºÅ',
                    replaySameSeed: 'Âêå„Åò„É©„Ç¶„É≥„Éâ„ÇíÂÜç„Éó„É¨„Ç§',
                    shareResult: 'ÁµêÊûú„Çí„Ç∑„Çß„Ç¢',
                    copied: '„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü',
                    shareFailed: '„Ç∑„Çß„Ç¢„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÅÊâãÂãï„Åß„Ç≥„Éî„Éº„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
                    shareText: 'ÁßÅ„ÅØhttps://poe.com/pokergrid„Åß‰πùÂÆÆÁâå„Çí{score}ÁÇπ„Å®„ÅÑ„ÅÜÂ•ΩÊàêÁ∏æ„Åß„Éó„É¨„Ç§„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„É©„É≥„ÉÄ„É†„Ç∑„Éº„Éâ„ÅØ{seed}„Åß„Åô„ÄÇ‰∏ÄÁ∑í„Å´„Éó„É¨„Ç§„Åó„Åæ„Åõ„Çì„ÅãÔºÅ',
                    comboClearing: '{count}ÈÄ£Á∂öÊ∂àÂéª! ({multiplier}ÂÄç„Éù„Ç§„É≥„Éà)',
                    patternPoints: '{pattern}! +{points}ÁÇπ',
                    cleared: 'Ê∂àÂéª',
                    singlePattern: '{pattern}„ÇíÊ∂àÂéª [{cards}] = {points}ÁÇπ',
                    multiplePattern: '{count}ÈÄ£Á∂öÊ∂àÂéª! ({multiplier}) = {points}ÁÇπ',
                    gameOverMessage: '„Ç≤„Éº„É†ÁµÇ‰∫ÜÔºÅ',
                    // Card pattern names
                    'flush': '„Éï„É©„ÉÉ„Ç∑„É•',
                    'straight': '„Çπ„Éà„É¨„Éº„Éà',
                    'threeOfAKind': '„Çπ„É™„Éº„Ç´„Éº„Éâ',
                    'straightFlush': '„Çπ„Éà„É¨„Éº„Éà„Éï„É©„ÉÉ„Ç∑„É•'
                },
                'ko': {
                    name: 'ÌïúÍµ≠Ïñ¥',
                    gameTitle: 'Íµ¨Í∂Å Ïπ¥Îìú',
                    gameDescription: 'ÌîåÎü¨Ïãú(50Ï†ê), Ïä§Ìä∏Î†àÏù¥Ìä∏(100Ï†ê), Ìä∏Î¶¨Ìîå(100Ï†ê) ÎòêÎäî Ïä§Ìä∏Î†àÏù¥Ìä∏ ÌîåÎü¨Ïãú(200Ï†ê)Î•º ÌòïÏÑ±ÌïòÏó¨ Ìñâ, Ïó¥ ÎòêÎäî ÎåÄÍ∞ÅÏÑ† Ï†úÍ±∞',
                    comboDescription: 'ÎèôÏãú Ï†úÍ±∞: 2Ïó∞ÏÜç√ó2Î∞∞, 3Ïó∞ÏÜç√ó4Î∞∞, 4Ïó∞ÏÜç√ó8Î∞∞',
                    remainingCards: 'ÎÇ®ÏùÄ Ïπ¥Îìú',
                    score: 'Ï†êÏàò',
                    randomSeed: 'ÎûúÎç§ ÏãúÎìú',
                    copy: 'Î≥µÏÇ¨',
                    share: 'Í≥µÏú†',
                    restart: 'Îã§Ïãú ÏãúÏûë',
                    newGame: 'ÏÉà Í≤åÏûÑ',
                    enterSeed: 'ÌäπÏ†ï Í≤åÏûÑÏùÑ ÏãúÏûëÌï† ÏãúÎìú ÏûÖÎ†•',
                    start: 'ÏãúÏûë',
                    currentCard: 'ÌòÑÏû¨ Ïπ¥Îìú',
                    remainingDeck: 'ÎÇ®ÏùÄ Îç± ÏÉÅÌô©',
                    clearingRecord: 'Ï†úÍ±∞ Í∏∞Î°ù',
                    gameOver: 'Í≤åÏûÑ Ï¢ÖÎ£å!',
                    finalScore: 'ÏµúÏ¢Ö Ï†êÏàò',
                    playAgainPrompt: 'Îã§Ïãú Ìïú Î≤à ÎèÑÏ†ÑÌïòÏó¨ Îçî ÎÜíÏùÄ Ï†êÏàòÎ•º ÎÖ∏Î†§Î≥¥ÏÑ∏Ïöî!',
                    replaySameSeed: 'Í∞ôÏùÄ ÎùºÏö¥Îìú Îã§Ïãú ÌîåÎ†àÏù¥',
                    shareResult: 'Í≤∞Í≥º Í≥µÏú†',
                    copied: 'ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨Îê®',
                    shareFailed: 'Í≥µÏú† Ïã§Ìå®, ÏàòÎèôÏúºÎ°ú Î≥µÏÇ¨Ìï¥Ï£ºÏÑ∏Ïöî',
                    shareText: 'Ï†ÄÎäî https://poe.com/pokergridÏóêÏÑú Íµ¨Í∂Å Ïπ¥ÎìúÎ•º ÌîåÎ†àÏù¥ÌïòÏó¨ {score}Ï†êÏùò Ï¢ãÏùÄ ÏÑ±Ï†ÅÏùÑ ÏñªÏóàÏäµÎãàÎã§. ÎûúÎç§ ÏãúÎìúÎäî {seed}ÏûÖÎãàÎã§. Ìï®Íªò ÌîåÎ†àÏù¥Ìï¥Î≥¥ÏÑ∏Ïöî!',
                    comboClearing: '{count}Ïó∞ÏÜç Ï†úÍ±∞! ({multiplier}Î∞∞ Ï†êÏàò)',
                    patternPoints: '{pattern}! +{points}Ï†ê',
                    cleared: 'Ï†úÍ±∞',
                    singlePattern: '{pattern} Ï†úÍ±∞ [{cards}] = {points}Ï†ê',
                    multiplePattern: '{count}Ïó∞ÏÜç Ï†úÍ±∞! ({multiplier}) = {points}Ï†ê',
                    gameOverMessage: 'Í≤åÏûÑ Ï¢ÖÎ£å!',
                    // Card pattern names
                    'flush': 'ÌîåÎü¨Ïãú',
                    'straight': 'Ïä§Ìä∏Î†àÏù¥Ìä∏',
                    'threeOfAKind': 'Ìä∏Î¶¨Ìîå',
                    'straightFlush': 'Ïä§Ìä∏Î†àÏù¥Ìä∏ ÌîåÎü¨Ïãú'
                },
                'en': {
                    name: 'English',
                    gameTitle: 'Grid Poker',
                    gameDescription: 'Form Flush (50pts), Straight (100pts), Three of a Kind (100pts) or Straight Flush (200pts) to clear rows, columns or diagonals',
                    comboDescription: 'Simultaneous clearing: 2 patterns √ó2, 3 patterns √ó4, 4 patterns √ó8',
                    remainingCards: 'Cards left',
                    score: 'Score',
                    randomSeed: 'Random Seed',
                    copy: 'Copy',
                    share: 'Share',
                    restart: 'Restart',
                    newGame: 'New Game',
                    enterSeed: 'Enter seed to start specific game',
                    start: 'Start',
                    currentCard: 'Current Card',
                    remainingDeck: 'Remaining Cards in Deck',
                    clearingRecord: 'Clearing Record',
                    gameOver: 'Game Over!',
                    finalScore: 'Final Score',
                    playAgainPrompt: 'Play again to challenge for a higher score!',
                    replaySameSeed: 'Replay Same Round',
                    shareResult: 'Share Result',
                    copied: 'Copied to clipboard',
                    shareFailed: 'Share failed, please copy manually',
                    shareText: 'I\'m playing Grid Poker at https://poe.com/pokergrid with a good score of {score} points. The random seed is {seed}. Come play with me!',
                    comboClearing: '{count} patterns cleared! ({multiplier}√ó points)',
                    patternPoints: '{pattern}! +{points} pts',
                    cleared: 'Cleared',
                    singlePattern: 'Cleared {pattern} [{cards}] = {points} pts',
                    multiplePattern: '{count} patterns cleared! ({multiplier}) = {points} pts',
                    gameOverMessage: 'Game Over!',
                    // Card pattern names
                    'flush': 'Flush',
                    'straight': 'Straight',
                    'threeOfAKind': 'Three of a Kind',
                    'straightFlush': 'Straight Flush'
                },
                'fr': {
                    name: 'Fran√ßais',
                    gameTitle: 'Poker Grille',
                    gameDescription: 'Formez Couleur (50pts), Suite (100pts), Brelan (100pts) ou Quinte Flush (200pts) pour √©liminer lignes, colonnes ou diagonales',
                    comboDescription: '√âlimination simultan√©e : 2 motifs √ó2, 3 motifs √ó4, 4 motifs √ó8',
                    remainingCards: 'Cartes restantes',
                    score: 'Score',
                    randomSeed: 'Graine al√©atoire',
                    copy: 'Copier',
                    share: 'Partager',
                    restart: 'Recommencer',
                    newGame: 'Nouvelle partie',
                    enterSeed: 'Entrez une graine pour d√©marrer une partie sp√©cifique',
                    start: 'D√©marrer',
                    currentCard: 'Carte actuelle',
                    remainingDeck: 'Cartes restantes dans le paquet',
                    clearingRecord: 'Historique d\'√©limination',
                    gameOver: 'Partie termin√©e !',
                    finalScore: 'Score final',
                    playAgainPrompt: 'Rejouez pour battre votre score !',
                    replaySameSeed: 'Rejouer m√™me partie',
                    shareResult: 'Partager r√©sultat',
                    copied: 'Copi√© dans le presse-papiers',
                    shareFailed: '√âchec du partage, veuillez copier manuellement',
                    shareText: 'Je joue √† Poker Grille sur https://poe.com/pokergrid avec un bon score de {score} points. La graine al√©atoire est {seed}. Venez jouer avec moi !',
                    comboClearing: '{count} motifs √©limin√©s ! (points √ó{multiplier})',
                    patternPoints: '{pattern} ! +{points} pts',
                    cleared: '√âlimin√©',
                    singlePattern: '√âlimin√© {pattern} [{cards}] = {points} pts',
                    multiplePattern: '{count} motifs √©limin√©s ! ({multiplier}) = {points} pts',
                    gameOverMessage: 'Partie termin√©e !',
                    // Card pattern names
                    'flush': 'Couleur',
                    'straight': 'Suite',
                    'threeOfAKind': 'Brelan',
                    'straightFlush': 'Quinte Flush'
                },
                'de': {
                    name: 'Deutsch',
                    gameTitle: 'Raster-Poker',
                    gameDescription: 'Bilde Flush (50P), Straight (100P), Drilling (100P) oder Straight Flush (200P) um Reihen, Spalten oder Diagonalen zu entfernen',
                    comboDescription: 'Gleichzeitige Entfernung: 2 Muster √ó2, 3 Muster √ó4, 4 Muster √ó8',
                    remainingCards: 'Verbleibende Karten',
                    score: 'Punkte',
                    randomSeed: 'Zufallsseed',
                    copy: 'Kopieren',
                    share: 'Teilen',
                    restart: 'Neustart',
                    newGame: 'Neues Spiel',
                    enterSeed: 'Seed eingeben, um bestimmtes Spiel zu starten',
                    start: 'Start',
                    currentCard: 'Aktuelle Karte',
                    remainingDeck: 'Verbleibende Karten im Stapel',
                    clearingRecord: 'Entfernungsprotokoll',
                    gameOver: 'Spiel beendet!',
                    finalScore: 'Endpunktzahl',
                    playAgainPrompt: 'Spiele erneut, um eine h√∂here Punktzahl zu erreichen!',
                    replaySameSeed: 'Gleiche Runde wiederholen',
                    shareResult: 'Ergebnis teilen',
                    copied: 'In die Zwischenablage kopiert',
                    shareFailed: 'Teilen fehlgeschlagen, bitte manuell kopieren',
                    shareText: 'Ich spiele Raster-Poker auf https://poe.com/pokergrid mit einer guten Punktzahl von {score}. Der Zufallsseed ist {seed}. Spiel mit mir!',
                    comboClearing: '{count} Muster entfernt! (Punkte √ó{multiplier})',
                    patternPoints: '{pattern}! +{points} P',
                    cleared: 'Entfernt',
                    singlePattern: '{pattern} entfernt [{cards}] = {points} P',
                    multiplePattern: '{count} Muster entfernt! ({multiplier}) = {points} P',
                    gameOverMessage: 'Spiel beendet!',
                    // Card pattern names
                    'flush': 'Flush',
                    'straight': 'Straight',
                    'threeOfAKind': 'Drilling',
                    'straightFlush': 'Straight Flush'
                },
                'es': {
                    name: 'Espa√±ol',
                    gameTitle: 'P√≥ker de Cuadr√≠cula',
                    gameDescription: 'Forma Color (50pts), Escalera (100pts), Tr√≠o (100pts) o Escalera de Color (200pts) para eliminar filas, columnas o diagonales',
                    comboDescription: 'Eliminaci√≥n simult√°nea: 2 patrones √ó2, 3 patrones √ó4, 4 patrones √ó8',
                    remainingCards: 'Cartas restantes',
                    score: 'Puntuaci√≥n',
                    randomSeed: 'Semilla aleatoria',
                    copy: 'Copiar',
                    share: 'Compartir',
                    restart: 'Reiniciar',
                    newGame: 'Nuevo juego',
                    enterSeed: 'Introduce semilla para iniciar juego espec√≠fico',
                    start: 'Iniciar',
                    currentCard: 'Carta actual',
                    remainingDeck: 'Cartas restantes en la baraja',
                    clearingRecord: 'Registro de eliminaciones',
                    gameOver: '¬°Juego terminado!',
                    finalScore: 'Puntuaci√≥n final',
                    playAgainPrompt: '¬°Juega de nuevo para conseguir una puntuaci√≥n m√°s alta!',
                    replaySameSeed: 'Repetir misma ronda',
                    shareResult: 'Compartir resultado',
                    copied: 'Copiado al portapapeles',
                    shareFailed: 'Error al compartir, por favor copia manualmente',
                    shareText: 'Estoy jugando P√≥ker de Cuadr√≠cula en https://poe.com/pokergrid con una buena puntuaci√≥n de {score} puntos. La semilla aleatoria es {seed}. ¬°Ven a jugar conmigo!',
                    comboClearing: '¬°{count} patrones eliminados! (puntos √ó{multiplier})',
                    patternPoints: '¬°{pattern}! +{points} pts',
                    cleared: 'Eliminado',
                    singlePattern: 'Eliminado {pattern} [{cards}] = {points} pts',
                    multiplePattern: '¬°{count} patrones eliminados! ({multiplier}) = {points} pts',
                    gameOverMessage: '¬°Juego terminado!',
                    // Card pattern names
                    'flush': 'Color',
                    'straight': 'Escalera',
                    'threeOfAKind': 'Tr√≠o',
                    'straightFlush': 'Escalera de Color'
                },
                'pt': {
                    name: 'Portugu√™s',
                    gameTitle: 'Poker de Grade',
                    gameDescription: 'Forme Flush (50pts), Sequ√™ncia (100pts), Trinca (100pts) ou Straight Flush (200pts) para limpar linhas, colunas ou diagonais',
                    comboDescription: 'Limpeza simult√¢nea: 2 padr√µes √ó2, 3 padr√µes √ó4, 4 padr√µes √ó8',
                    remainingCards: 'Cartas restantes',
                    score: 'Pontua√ß√£o',
                    randomSeed: 'Semente aleat√≥ria',
                    copy: 'Copiar',
                    share: 'Compartilhar',
                    restart: 'Reiniciar',
                    newGame: 'Novo jogo',
                    enterSeed: 'Digite uma semente para iniciar um jogo espec√≠fico',
                    start: 'Iniciar',
                    currentCard: 'Carta atual',
                    remainingDeck: 'Cartas restantes no baralho',
                    clearingRecord: 'Registro de limpezas',
                    gameOver: 'Fim de jogo!',
                    finalScore: 'Pontua√ß√£o final',
                    playAgainPrompt: 'Jogue novamente para um desafio de pontua√ß√£o mais alta!',
                    replaySameSeed: 'Repetir mesma rodada',
                    shareResult: 'Compartilhar resultado',
                    copied: 'Copiado para a √°rea de transfer√™ncia',
                    shareFailed: 'Falha ao compartilhar, por favor copie manualmente',
                    shareText: 'Estou jogando Poker de Grade em https://poe.com/pokergrid com uma boa pontua√ß√£o de {score} pontos. A semente aleat√≥ria √© {seed}. Venha jogar comigo!',
                    comboClearing: '{count} padr√µes limpos! (pontos √ó{multiplier})',
                    patternPoints: '{pattern}! +{points} pts',
                    cleared: 'Limpo',
                    singlePattern: 'Limpo {pattern} [{cards}] = {points} pts',
                    multiplePattern: '{count} padr√µes limpos! ({multiplier}) = {points} pts',
                    gameOverMessage: 'Fim de jogo!',
                    // Card pattern names
                    'flush': 'Flush',
                    'straight': 'Sequ√™ncia',
                    'threeOfAKind': 'Trinca',
                    'straightFlush': 'Straight Flush'
                }
            };
            
            // Default language
            let currentLanguage = 'zh-CN';
            
            // Try to detect user's browser language
            function detectBrowserLanguage() {
                const browserLang = navigator.language || navigator.userLanguage;
                const shortLang = browserLang.split('-')[0];
                
                // Check if we have an exact match
                if (LANGUAGES[browserLang]) {
                    return browserLang;
                }
                
                // Check for language matches
                for (const lang in LANGUAGES) {
                    if (lang.startsWith(shortLang)) {
                        return lang;
                    }
                }
                
                // Default to Chinese if no match
                return 'zh-CN';
            }
            
            // Initialize language selector
            function initLanguageSelector() {
                const selector = document.getElementById('language-selector');
                
                // Add options for each language
                for (const lang in LANGUAGES) {
                    const option = document.createElement('option');
                    option.value = lang;
                    option.textContent = LANGUAGES[lang].name;
                    selector.appendChild(option);
                }
                
                // Set initial language
                currentLanguage = detectBrowserLanguage();
                selector.value = currentLanguage;
                
                // Apply translations
                applyTranslations();
                
                // Add event listener for language change
                selector.addEventListener('change', (event) => {
                    currentLanguage = event.target.value;
                    applyTranslations();
                });
            }
            
            // Get translation for a key
            function t(key, replacements = {}) {
                let text = LANGUAGES[currentLanguage][key] || LANGUAGES['en'][key] || key;
                
                // Apply replacements
                for (const [placeholder, value] of Object.entries(replacements)) {
                    text = text.replace(`{${placeholder}}`, value);
                }
                
                return text;
            }
            
            // Apply translations to all elements with data-i18n attribute
            function applyTranslations() {
                document.querySelectorAll('[data-i18n]').forEach(element => {
                    const key = element.getAttribute('data-i18n');
                    element.textContent = t(key);
                });
                
                // Apply placeholder translations
                document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
                    const key = element.getAttribute('data-i18n-placeholder');
                    element.placeholder = t(key);
                });
                
                // Update dynamic content if needed
                updateDynamicContent();
            }
            
            // Update dynamic content that needs translation
            function updateDynamicContent() {
                // This function can be expanded as needed
            }
            
            // Check for dark mode preference
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }
            
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                if (event.matches) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            });

            // Game constants
            const SUITS = ['heart', 'diamond', 'spade', 'club'];
            const SUIT_SYMBOLS = {
                'heart': '‚ô•',
                'diamond': '‚ô¶',
                'spade': '‚ô†',
                'club': '‚ô£'
            };
            const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const RANK_VALUES = {
                'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,
                '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
            };
            
            const SCORE_VALUES = {
                'flush': 50,        // ÂêåËä±
                'straight': 100,    // È°∫Â≠ê
                'threeOfAKind': 100,// ‰∏âÊù°
                'straightFlush': 200// ÂêåËä±È°∫
            };
            
            // ÁâπÊÆäÂä†ÂàÜËßÑÂàô
            const COMBO_MULTIPLIERS = {
                2: 2,  // ÂèåÊ∂àÈô§ 2ÂÄçÂàÜÊï∞
                3: 4,  // ‰∏âËøûÊ∂àÈô§ 4ÂÄçÂàÜÊï∞
                4: 8   // ÂõõËøûÊ∂àÈô§ 8ÂÄçÂàÜÊï∞
            };

            // Game state
            let deck = [];
            let grid = Array(9).fill(null);
            let currentCard = null;
            let score = 0;
            let currentSeed = '';
            let gameOver = false;
            let seededRandom = null;

            // DOM elements
            const gridContainer = document.querySelector('.grid');
            const scoreDisplay = document.getElementById('score');
            const remainingCardsDisplay = document.getElementById('remaining-cards');
            const currentCardElement = document.getElementById('current-card');
            const seedDisplay = document.getElementById('seed-display');
            const gameMessage = document.getElementById('game-message');
            const resultModal = document.getElementById('result-modal');
            const finalScoreDisplay = document.getElementById('final-score');
            const newGameBtn = document.getElementById('new-game-btn');
            const copySeedBtn = document.getElementById('copy-seed');
            const seedInput = document.getElementById('seed-input');
            const startFromSeedBtn = document.getElementById('start-from-seed');
            const playAgainBtn = document.getElementById('play-again');
            const toastElement = document.getElementById('toast');

            // Create a seeded random number generator
            function createSeededRandom(seed) {
                // Simple hash function for seed
                let hash = Array.from(seed).reduce((acc, char) => {
                    return ((acc << 5) - acc) + char.charCodeAt(0) | 0;
                }, 0);
                
                return function() {
                    const x = Math.sin(hash++) * 10000;
                    return x - Math.floor(x);
                };
            }

            // Initialize the game board
            function initializeGrid() {
                gridContainer.innerHTML = '';
                
                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('card', 'w-16', 'h-24', 'md:w-20', 'md:h-30', 'bg-white', 'dark:bg-gray-800', 'border', 'border-gray-300', 'dark:border-gray-700', 'rounded-lg', 'shadow-md', 'flex', 'items-center', 'justify-center', 'cursor-pointer', 'hover:border-primary', 'dark:hover:border-primary');
                    cell.dataset.index = i;
                    
                    // Add click event
                    cell.addEventListener('click', () => {
                        if (!gameOver && currentCard && !grid[i]) {
                            placeCard(i);
                        }
                    });
                    
                    gridContainer.appendChild(cell);
                }
            }

            // Create and shuffle deck
            function createDeck() {
                const deck = [];
                
                for (const suit of SUITS) {
                    for (const rank of RANKS) {
                        deck.push({ suit, rank });
                    }
                }
                
                return deck;
            }

            // Fisher-Yates shuffle using seeded random
            function shuffleDeck(deck) {
                const shuffled = [...deck];
                
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(seededRandom() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                
                return shuffled;
            }

            // Draw the next card from the deck
            function drawCard() {
                if (deck.length === 0) {
                    return null;
                }
                
                remainingCardsDisplay.textContent = deck.length - 1;
                return deck.pop();
            }

            // Display a card in the current card slot
            function displayCurrentCard(card) {
                if (!card) {
                    currentCardElement.innerHTML = `
                        <div class="card-inner">
                            <div class="card-front flex items-center justify-center">
                                <span>-</span>
                            </div>
                        </div>
                    `;
                    return;
                }
                
                const { suit, rank } = card;
                currentCardElement.innerHTML = `
                    <div class="card-inner">
                        <div class="card-front flex flex-col items-center justify-center">
                            <div class="text-xs md:text-sm">${rank}</div>
                            <div class="${suit} text-lg md:text-xl">${SUIT_SYMBOLS[suit]}</div>
                        </div>
                    </div>
                `;
            }

            // Place a card on the grid
            function placeCard(index) {
                if (grid[index] || !currentCard) {
                    return;
                }
                
                grid[index] = currentCard;
                const cell = gridContainer.children[index];
                const { suit, rank } = currentCard;
                
                cell.innerHTML = `
                    <div class="card-front flex flex-col items-center justify-center card-fade-in">
                        <div class="text-xs md:text-sm">${rank}</div>
                        <div class="${suit} text-lg md:text-xl">${SUIT_SYMBOLS[suit]}</div>
                    </div>
                `;
                
                cell.classList.remove('hover:border-primary', 'dark:hover:border-primary', 'cursor-pointer');
                
                // Check for completed patterns
                checkPatterns();
                
                // Draw the next card
                currentCard = drawCard();
                displayCurrentCard(currentCard);
                
                // Update card counter
                updateCardCounter();
                
                // Check if the game is over
                checkGameOver();
            }

            // Check for completed patterns (rows, columns, diagonals)
            function checkPatterns() {
                const patterns = [
                    // Rows
                    [0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8],
                    // Columns
                    [0, 3, 6],
                    [1, 4, 7],
                    [2, 5, 8],
                    // Diagonals
                    [0, 4, 8],
                    [2, 4, 6]
                ];
                
                const validPatterns = [];
                
                // Collect all valid patterns
                for (const pattern of patterns) {
                    if (pattern.every(index => grid[index])) {
                        const cards = pattern.map(index => grid[index]);
                        const patternType = getPatternType(cards);
                        
                        if (patternType) {
                            validPatterns.push({ pattern, patternType });
                        }
                    }
                }
                
                // If we have valid patterns, process them
                if (validPatterns.length > 0) {
                    processPatterns(validPatterns);
                }
            }
            
            // Process multiple patterns at once if needed
            function processPatterns(validPatterns) {
                // ÂÖàËÆ°ÁÆóÊâÄÊúâÁâåÂûãÁöÑÂü∫Á°ÄÂàÜÊï∞ÊÄªÂíå
                let baseTotalPoints = 0;
                let allCellsToRemove = new Set();
                let patternDetails = [];
                
                // Êî∂ÈõÜÊâÄÊúâÁâåÂûãÁöÑÂü∫Á°ÄÂàÜÂíåÂç°Áâå
                for (const { pattern, patternType } of validPatterns) {
                    const basePoints = SCORE_VALUES[patternType];
                    baseTotalPoints += basePoints;
                    
                    // Ëé∑ÂèñÊ≠§ÁâåÂûã‰∏≠ÁöÑÂç°ÁâåÁî®‰∫éÊó•ÂøóËÆ∞ÂΩï
                    const cardsInPattern = pattern.map(index => grid[index]);
                    
                    // Ê∑ªÂä†ÂçïÂÖÉÊ†ºÂà∞Ê∏ÖÈô§ÈõÜÂêà
                    pattern.forEach(index => allCellsToRemove.add(index));
                    
                    // ÂÖàÂ≠òÂÇ®Âü∫Á°Ä‰ø°ÊÅØÔºà‰πãÂêé‰ºöÊõ¥Êñ∞ÂàÜÊï∞Ôºâ
                    patternDetails.push({
                        type: patternType,
                        basePoints: basePoints,
                        cards: cardsInPattern
                    });
                }
                
                // Ê†πÊçÆËøûÊ∂àÊ¨°Êï∞Á°ÆÂÆö‰πòÊï∞
                let multiplier = 1;
                if (validPatterns.length === 2) {
                    multiplier = COMBO_MULTIPLIERS[2]; // ÂèåÊ∂àÈô§ x2
                } else if (validPatterns.length === 3) {
                    multiplier = COMBO_MULTIPLIERS[3]; // ‰∏âËøûÊ∂àÈô§ x4
                } else if (validPatterns.length >= 4) {
                    multiplier = COMBO_MULTIPLIERS[4]; // ÂõõËøûÊ∂àÈô§ x8
                }
                
                // ËÆ°ÁÆóÊúÄÁªàÊÄªÂàÜÔºàÂü∫Á°ÄÂàÜÊï∞‰πãÂíå √ó ‰πòÊï∞Ôºâ
                const totalPoints = baseTotalPoints * multiplier;
                
                // Êõ¥Êñ∞ÊØè‰∏™ÁâåÂûãÁöÑÊòæÁ§∫ÂàÜÊï∞ÔºàÁî®‰∫éÊó•ÂøóÊòæÁ§∫Ôºâ
                patternDetails = patternDetails.map(pattern => {
                    // ËÆ°ÁÆóÊ≠§ÁâåÂûãË¥°ÁåÆÁöÑÊúÄÁªàÂàÜÊï∞ÔºöÂü∫Á°ÄÂàÜÊï∞Âú®ÊÄªÂàÜ‰∏≠ÁöÑÂç†ÊØî √ó ÊúÄÁªàÊÄªÂàÜ
                    const ratio = pattern.basePoints / baseTotalPoints;
                    const points = Math.round(totalPoints * ratio);
                    
                    return {
                        ...pattern,
                        points: points  // Êõ¥Êñ∞‰∏∫Ë¥°ÁåÆÁöÑÊúÄÁªàÂàÜÊï∞
                    };
                });
                
                // Update score
                score += totalPoints;
                scoreDisplay.textContent = score;
                
                // Create message about patterns and points
                let comboText = '';
                let gameMessageText = '';
                
                if (validPatterns.length >= 2) {
                    comboText = t('comboClearing', {count: validPatterns.length, multiplier: multiplier});
                    gameMessageText = `${comboText} +${totalPoints}`;
                } else {
                    const patternType = validPatterns[0].patternType;
                    gameMessageText = t('patternPoints', {pattern: t(patternType), points: totalPoints});
                }
                
                // Show message
                gameMessage.textContent = gameMessageText;
                gameMessage.classList.add('text-primary', 'font-bold');
                
                // Add log entry
                addLogEntry(patternDetails, validPatterns.length, totalPoints);
                
                // Clear cells with animation
                const cellsToRemove = Array.from(allCellsToRemove);
                for (const index of cellsToRemove) {
                    const cell = gridContainer.children[index];
                    
                    // Ê∑ªÂä†ÂÆâÂÖ®ÁöÑÂÖÉÁ¥†Ê∑°Âá∫Âä®Áîª
                    try {
                        // ‰ΩøÁî®querySelectorËÄå‰∏çÊòØfirstChildÔºåÊõ¥ÊòéÁ°ÆÂú∞ÈÄâÊã©ÂÖÉÁ¥†
                        const cardElement = cell.querySelector('.card-front');
                        if (cardElement) {
                            // ÁßªÈô§Ê∑°ÂÖ•Âä®ÁîªÁ±ªÂπ∂Ê∑ªÂä†Ê∑°Âá∫Âä®ÁîªÁ±ª
                            cardElement.classList.remove('card-fade-in');
                            cardElement.classList.add('card-fade-out');
                        }
                    } catch (e) {
                        console.error("Animation error:", e);
                    }
                    
                    // ËÆæÁΩÆÂª∂Êó∂Ê∏ÖÁ©∫ÂçïÂÖÉÊ†º
                    setTimeout(() => {
                        cell.innerHTML = '';
                        cell.classList.add('hover:border-primary', 'dark:hover:border-primary', 'cursor-pointer');
                        grid[index] = null;
                        
                        // Êõ¥Êñ∞ËÆ∞ÁâåÂô®Áä∂ÊÄÅÔºåÁ°Æ‰øùÊ∏ÖÈô§ÁâåÂêéËÆ∞ÁâåÂô®‰πüÊõ¥Êñ∞
                        updateCardCounter();
                    }, 300);
                }
                
                // Reset message after a delay
                setTimeout(() => {
                    gameMessage.textContent = '';
                    gameMessage.classList.remove('text-primary', 'font-bold');
                }, 2000);
            }
            
            // Add a log entry about pattern clearing
            function addLogEntry(patternDetails, patternCount, totalPoints) {
                const gameLog = document.querySelector('#game-log div');
                const logEntry = document.createElement('div');
                
                // Format card display for log
                function formatCards(cards) {
                    return cards.map(card => {
                        let colorClass = '';
                        if (card.suit === 'heart') {
                            colorClass = 'text-red-600 dark:text-red-400'; // Á∫¢Ê°ÉÁ∫¢Ëâ≤
                        } else if (card.suit === 'diamond') {
                            colorClass = 'text-orange-500 dark:text-orange-300'; // ÊñπÂùóÊ©ôËâ≤
                        } else if (card.suit === 'spade') {
                            colorClass = 'text-purple-600 dark:text-purple-400'; // ÈªëÊ°ÉÁ¥´Ëâ≤
                        }
                        return `<span class="${colorClass}">${card.rank}${SUIT_SYMBOLS[card.suit]}</span>`;
                    }).join(' ');
                }
                
                // Format details based on number of patterns
                if (patternCount > 1) {
                    // Multiple pattern details
                    let patternsHtml = patternDetails.map(p => {
                        return `<div class="ml-1 mt-1"><span class="font-semibold text-primary">${t(p.type)}</span> [${formatCards(p.cards)}] = <span class="font-bold">${p.points}${t('score').substring(0,1)}</span></div>`;
                    }).join('');
                    
                    let multiplierText;
                    if (patternCount >= 4) {
                        multiplierText = '8√ó';
                    } else if (patternCount === 3) {
                        multiplierText = '4√ó';
                    } else {
                        multiplierText = '2√ó';
                    }
                    
                    logEntry.innerHTML = t('multiplePattern', {
                        count: patternCount,
                        multiplier: multiplierText,
                        points: totalPoints
                    });
                    
                    logEntry.innerHTML += patternsHtml;
                } else {
                    // Single pattern
                    const pattern = patternDetails[0];
                    logEntry.innerHTML = t('singlePattern', {
                        pattern: t(pattern.type),
                        cards: formatCards(pattern.cards),
                        points: pattern.points
                    });
                }
                
                logEntry.classList.add('text-sm', 'py-1', 'border-b', 'border-gray-200', 'dark:border-gray-700', 'pb-2', 'mb-1');
                gameLog.prepend(logEntry);
            }

            // Identify the pattern type if any
            function getPatternType(cards) {
                // Check for straight flush (ÂêåËä±È°∫)
                if (isStraight(cards) && isFlush(cards)) {
                    return 'straightFlush';
                }
                
                // Check for flush (ÂêåËä±)
                if (isFlush(cards)) {
                    return 'flush';
                }
                
                // Check for straight (È°∫Â≠ê)
                if (isStraight(cards)) {
                    return 'straight';
                }
                
                // Check for three of a kind (‰∏âÊù°)
                if (isThreeOfAKind(cards)) {
                    return 'threeOfAKind';
                }
                
                return null;
            }

            // Check if cards form a flush (same suit)
            function isFlush(cards) {
                const firstSuit = cards[0].suit;
                return cards.every(card => card.suit === firstSuit);
            }

            // Check if cards form a straight (sequential values)
            function isStraight(cards) {
                const values = cards.map(card => RANK_VALUES[card.rank]).sort((a, b) => a - b);
                
                // Special case for A-K-Q
                if (values[0] === 1 && values[1] === 12 && values[2] === 13) {
                    return true;
                }
                
                // Special case for A-2-3
                if (values[0] === 1 && values[1] === 2 && values[2] === 3) {
                    return true;
                }
                
                // Check for sequential values
                return values[1] === values[0] + 1 && values[2] === values[1] + 1;
            }

            // Check if cards form three of a kind (same rank)
            function isThreeOfAKind(cards) {
                const firstRank = cards[0].rank;
                return cards.every(card => card.rank === firstRank);
            }

            // Ê£ÄÊü•ÊòØÂê¶ÊúâÂèØÊ∂àÈô§ÁöÑÁâåÂûã
            function hasValidPatterns() {
                const patterns = [
                    // Rows
                    [0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8],
                    // Columns
                    [0, 3, 6],
                    [1, 4, 7],
                    [2, 5, 8],
                    // Diagonals
                    [0, 4, 8],
                    [2, 4, 6]
                ];
                
                // Ê£ÄÊü•ÊòØÂê¶Â≠òÂú®ÊúâÊïàÁöÑÊ®°Âºè
                for (const pattern of patterns) {
                    if (pattern.every(index => grid[index])) {
                        const cards = pattern.map(index => grid[index]);
                        const patternType = getPatternType(cards);
                        
                        if (patternType) {
                            return true; // ÊâæÂà∞‰∏Ä‰∏™ÂèØÊ∂àÈô§ÁöÑÁâåÂûã
                        }
                    }
                }
                
                return false; // Ê≤°ÊúâÊâæÂà∞ÂèØÊ∂àÈô§ÁöÑÁâåÂûã
            }
            
            // Check if the game is over
            function checkGameOver() {
                // Â¶ÇÊûúÁâåÂ∑≤Áî®ÂÆå‰∏îÊ≤°ÊúâÂΩìÂâçÁâåÔºåÊàñËÄÖÊ†ºÂ≠êÂ∑≤Â°´Êª°‰∏îÊ≤°ÊúâÂèØÊ∂àÈô§ÁöÑÁâåÂûãÔºåÂàôÊ∏∏ÊàèÁªìÊùü
                const gridIsFull = grid.every(cell => cell !== null);
                const noMoreCards = deck.length === 0 && !currentCard;
                
                // Â¶ÇÊûúÊ†ºÂ≠êÂ∑≤Êª°Ôºå‰ΩÜËøòÊúâÂèØÊ∂àÈô§ÁöÑÁâåÂûãÔºåÈÇ£‰πàÊ∏∏ÊàèËøòÊ≤°ÁªìÊùü
                if (gridIsFull && hasValidPatterns()) {
                    return; // ‰ªçÊúâÂèØÊ∂àÈô§ÁöÑÁâåÂûãÔºåÊ∏∏ÊàèÁªßÁª≠
                }
                
                // Â¶ÇÊûúÁâåÁî®ÂÆåÊàñÊ†ºÂ≠êÂ°´Êª°‰∏îÊó†Ê≥ïÊ∂àÈô§ÔºåÂàôÊ∏∏ÊàèÁªìÊùü
                if (noMoreCards || gridIsFull) {
                    gameOver = true;
                    
                    // Show result modal
                    finalScoreDisplay.textContent = score;
                    resultModal.classList.remove('hidden');
                    
                    // Display game over message
                    gameMessage.textContent = t('gameOverMessage');
                }
            }

            // ÂàùÂßãÂåñËÆ∞ÁâåÂô®
            function initializeCardCounter() {
                const cardCounter = document.getElementById('card-counter');
                cardCounter.innerHTML = '';
                
                // Ê∑ªÂä†Ëä±Ëâ≤Ê†áÈ¢òË°å
                const headerRow = document.createElement('div');
                headerRow.classList.add('contents');
                
                // Ê∑ªÂä†Ëä±Ëâ≤Ê†áÈ¢ò - ÊåâÈªëÁ∫¢Ê¢ÖÊñπÈ°∫Â∫èÊéíÂàó
                const suits = ['spade', 'heart', 'club', 'diamond'];
                const suitNames = {
                    'spade': '‚ô†',  // Á¥´Ëâ≤
                    'heart': '‚ô•',  // Á∫¢Ëâ≤
                    'club': '‚ô£',   // ÈªëËâ≤
                    'diamond': '‚ô¶'  // Ê©ôËâ≤
                };
                
                suits.forEach(suit => {
                    const suitHeader = document.createElement('div');
                    suitHeader.classList.add('font-bold', 'mb-1', suit);
                    suitHeader.textContent = suitNames[suit];
                    headerRow.appendChild(suitHeader);
                });
                
                cardCounter.appendChild(headerRow);
                
                // Ê∑ªÂä†ÁâåÈù¢ - ‰ªéAÂà∞2ÔºåÂÄíÂ∫èÊéíÂàó
                const ranks = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2'];
                
                // ‰∏∫ÊØè‰∏™ÁâåÈù¢ÂàõÂª∫‰∏ÄË°å
                ranks.forEach(rank => {
                    const rankRow = document.createElement('div');
                    rankRow.classList.add('contents');
                    
                    // ‰∏∫ÊØè‰∏™Ëä±Ëâ≤ÂàõÂª∫‰∏Ä‰∏™ÂçïÂÖÉÊ†º
                    suits.forEach(suit => {
                        const card = document.createElement('div');
                        card.classList.add('text-xs', 'py-1', suit);
                        card.id = `card-${suit}-${rank}`;
                        card.dataset.rank = rank; // ‰øùÂ≠òÂéüÂßãÁâåÈù¢ÂÄºÔºåÁî®‰∫éÈáçÁΩÆÊòæÁ§∫
                        card.textContent = rank;
                        rankRow.appendChild(card);
                    });
                    
                    cardCounter.appendChild(rankRow);
                });
            }
            
            // Êõ¥Êñ∞ËÆ∞ÁâåÂô®ÊòæÁ§∫
            function updateCardCounter() {
                // È¶ñÂÖàÈáçÁΩÆÊâÄÊúâÁâåÁöÑÂèØËßÅÊÄß
                document.querySelectorAll('#card-counter [id^="card-"]').forEach(card => {
                    card.textContent = card.dataset.rank; // ÊÅ¢Â§çÊâÄÊúâÁâåÁöÑÊòæÁ§∫
                });
                
                // Â§ÑÁêÜÊâÄÊúâÁâå
                for (const suit of SUITS) {
                    for (const rank of RANKS) {
                        // Ê£ÄÊü•ÊòØÂê¶ËøòÊúâËøôÂº†ÁâåÂú®ÁâåÁªÑ‰∏≠
                        const isInDeck = deck.some(card => card.suit === suit && card.rank === rank);
                        
                        // Â¶ÇÊûú‰∏çÂú®ÁâåÁªÑ‰∏≠(Â∑≤ÁªèË¢´ÊäΩÂá∫)ÔºåÊàñËÄÖÊòØÂΩìÂâçÁâåÊàñ‰πùÂÆ´Ê†ºÂå∫ÂüüÁöÑÁâåÔºåÈÉΩÂ∫î‰ªéËÆ∞ÁâåÂô®‰∏≠ÁßªÈô§
                        if (!isInDeck || 
                            (currentCard && currentCard.suit === suit && currentCard.rank === rank) || 
                            grid.some(card => card && card.suit === suit && card.rank === rank)) {
                            
                            // ‰ªéËÆ∞ÁâåÂô®‰∏≠ÁßªÈô§Ê≠§Áâå
                            const cardElement = document.getElementById(`card-${suit}-${rank}`);
                            if (cardElement) {
                                cardElement.textContent = ''; // Ê∏ÖÁ©∫ÊñáÂ≠óÔºå‰∏çÊòæÁ§∫
                            }
                        }
                    }
                }
            }
            
            // Show toast notification
            function showToast(message) {
                toastElement.textContent = message;
                toastElement.classList.add('opacity-100');
                
                setTimeout(() => {
                    toastElement.classList.remove('opacity-100');
                }, 2000);
            }
            
            // Share game with others
            function shareGame() {
                const shareText = t('shareText', {score: score, seed: currentSeed});
                
                navigator.clipboard.writeText(shareText).then(() => {
                    showToast(t('copied'));
                }).catch(err => {
                    console.error('Share failed:', err);
                    showToast(t('shareFailed'));
                });
            }
            
            // Start a new game with an optional seed
            function startGame(seed = null) {
                // Generate or use provided seed
                currentSeed = seed || crypto.randomUUID();
                seedDisplay.textContent = currentSeed;
                
                // Initialize seeded random
                seededRandom = createSeededRandom(currentSeed);
                
                // Reset game state
                grid = Array(9).fill(null);
                score = 0;
                gameOver = false;
                
                // Create and shuffle deck
                deck = createDeck();
                deck = shuffleDeck(deck);
                
                // Update displays
                scoreDisplay.textContent = score;
                remainingCardsDisplay.textContent = deck.length;
                
                // Draw first card
                currentCard = drawCard();
                displayCurrentCard(currentCard);
                
                // Initialize grid
                initializeGrid();
                
                // Initialize and update card counter
                initializeCardCounter();
                updateCardCounter();
                
                // Hide modal if visible
                resultModal.classList.add('hidden');
                
                // Reset message
                gameMessage.textContent = '';
                gameMessage.classList.remove('text-primary', 'font-bold');
            }
            
            // Event listeners
            function setupEventListeners() {
                newGameBtn.addEventListener('click', () => {
                    // Ê∏ÖÁ©∫Ê∏∏ÊàèÊó•ÂøóÔºàÂè™Âú®ÂºÄÂßãÊñ∞Ê∏∏ÊàèÊó∂Ê∏ÖÁ©∫ÔºåËÄå‰∏çÊòØÂú®Ê∏∏ÊàèÁªìÊùüÊó∂Ôºâ
                    const gameLog = document.querySelector('#game-log div');
                    gameLog.innerHTML = '';
                    
                    startGame();
                });
                
                // Ê∑ªÂä†È™∞Â≠êÊåâÈíÆÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®ÔºåÁî®‰∫éÁîüÊàêÊñ∞ÁöÑÈöèÊú∫ÁßçÂ≠êÔºå‰ΩÜ‰ΩøÁî®Áõ∏ÂêåÁöÑÊ∏∏Êàè
                document.getElementById('random-seed').addEventListener('click', () => {
                    // ÁîüÊàê‰∏Ä‰∏™Êñ∞ÁöÑÈöèÊú∫ÁßçÂ≠ê
                    const newSeed = crypto.randomUUID();
                    // Â∞ÜÂÆÉÊ∑ªÂä†Âà∞ËæìÂÖ•Ê°Ü‰∏≠
                    seedInput.value = newSeed;
                    // È´ò‰∫ÆÊòæÁ§∫ËæìÂÖ•Ê°ÜÔºå‰ª•‰æøÁî®Êà∑Ê≥®ÊÑèÂà∞ÂèòÂåñ
                    seedInput.classList.add('bg-yellow-50', 'dark:bg-yellow-900');
                    setTimeout(() => {
                        seedInput.classList.remove('bg-yellow-50', 'dark:bg-yellow-900');
                    }, 1000);
                });
                
                copySeedBtn.addEventListener('click', () => {
                    navigator.clipboard.writeText(currentSeed).then(() => {
                        showToast(t('copied'));
                    });
                });
                
                // ÂàÜ‰∫´ÂΩìÂâçÊ∏∏Êàè
                document.getElementById('share-game').addEventListener('click', shareGame);
                
                // ÂàÜ‰∫´Ê∏∏ÊàèÁªìÊûú
                document.getElementById('share-result').addEventListener('click', shareGame);
                
                startFromSeedBtn.addEventListener('click', () => {
                    const seed = seedInput.value.trim();
                    if (seed) {
                        // Ê∏ÖÁ©∫Ê∏∏ÊàèÊó•ÂøóÔºàÂè™Âú®ÂºÄÂßãÊñ∞Ê∏∏ÊàèÊó∂Ê∏ÖÁ©∫Ôºâ
                        const gameLog = document.querySelector('#game-log div');
                        gameLog.innerHTML = '';
                        
                        startGame(seed);
                        seedInput.value = '';
                    }
                });
                
                playAgainBtn.addEventListener('click', () => {
                    // Ê∏ÖÁ©∫Ê∏∏ÊàèÊó•ÂøóÔºàÂè™Âú®ÂºÄÂßãÊñ∞Ê∏∏ÊàèÊó∂Ê∏ÖÁ©∫Ôºâ
                    const gameLog = document.querySelector('#game-log div');
                    gameLog.innerHTML = '';
                    
                    startGame(); // ÂºÄÂßãÊñ∞Ê∏∏ÊàèÔºåÈöèÊú∫ÁßçÂ≠ê
                });
                
                // Ê∑ªÂä†"ÈáçÁé©Êú¨Â±Ä"ÊåâÈíÆÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®ÔºàÊ∏∏ÊàèÁªìÊùüÂºπÁ™ó‰∏≠ÁöÑÔºâ
                document.getElementById('replay-same-seed').addEventListener('click', () => {
                    // Ê∏ÖÁ©∫Ê∏∏ÊàèÊó•Âøó
                    const gameLog = document.querySelector('#game-log div');
                    gameLog.innerHTML = '';
                    
                    // ‰ΩøÁî®Áõ∏ÂêåÁöÑÁßçÂ≠êÈáçÊñ∞ÂºÄÂßãÊ∏∏Êàè
                    startGame(currentSeed);
                });
                
                // Ê∑ªÂä†È°∂ÈÉ®"ÈáçÂºÄ"ÊåâÈíÆÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®
                document.getElementById('restart-game').addEventListener('click', () => {
                    // Ê∏ÖÁ©∫Ê∏∏ÊàèÊó•Âøó
                    const gameLog = document.querySelector('#game-log div');
                    gameLog.innerHTML = '';
                    
                    // ‰ΩøÁî®Áõ∏ÂêåÁöÑÁßçÂ≠êÈáçÊñ∞ÂºÄÂßãÊ∏∏Êàè
                    startGame(currentSeed);
                });
            }

            // Initialize game
            function init() {
                initLanguageSelector();
                setupEventListeners();
                startGame();
            }

            // Start the game when page loads
            window.addEventListener('DOMContentLoaded', init);
        </script>
    </div>
</body>
</html>
